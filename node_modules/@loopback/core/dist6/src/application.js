"use strict";
// Copyright IBM Corp. 2017. All Rights Reserved.
// Node module: @loopback/core
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const context_1 = require("@loopback/context");
const component_1 = require("./component");
const keys_1 = require("./keys");
/**
 * Application is the container for various types of artifacts, such as
 * components, servers, controllers, repositories, datasources, connectors,
 * and models.
 */
class Application extends context_1.Context {
    constructor(options) {
        super();
        this.options = options;
        if (!options)
            options = {};
        // Bind to self to allow injection of application context in other
        // modules.
        this.bind(keys_1.CoreBindings.APPLICATION_INSTANCE).to(this);
        // Make options available to other modules as well.
        this.bind(keys_1.CoreBindings.APPLICATION_CONFIG).to(options);
        if (options.components) {
            for (const component of options.components) {
                this.component(component);
            }
        }
        if (options.servers) {
            for (const name in options.servers) {
                this.server(options.servers[name], name);
            }
        }
        if (options.controllers) {
            for (const ctor of options.controllers) {
                this.controller(ctor);
            }
        }
    }
    /**
     * Register a controller class with this application.
     *
     * @param controllerCtor {Function} The controller class
     * (constructor function).
     * @return {Binding} The newly created binding, you can use the reference to
     * further modify the binding, e.g. lock the value to prevent further
     * modifications.
     *
     * ```ts
     * class MyController {
     * }
     * app.controller(MyController).lock();
     * ```
     */
    controller(controllerCtor) {
        return this.bind('controllers.' + controllerCtor.name).toClass(controllerCtor);
    }
    /**
     * Bind a Server constructor to the Application's master context.
     * Each server constructor added in this way must provide a unique prefix
     * to prevent binding overlap.
     *
     * ```ts
     * app.server(RestServer);
     * // This server constructor will be bound under "servers.RestServer".
     * app.server(RestServer, "v1API");
     * // This server instance will be bound under "servers.v1API".
     * ```
     *
     * @param {Constructor<Server>} server The server constructor.
     * @param {string=} name Optional override for key name.
     * @returns {Binding} Binding for the server class
     * @memberof Application
     */
    server(ctor, name) {
        const suffix = name || ctor.name;
        const key = `${keys_1.CoreBindings.SERVERS}.${suffix}`;
        return this.bind(key)
            .toClass(ctor)
            .inScope(context_1.BindingScope.SINGLETON);
    }
    /**
     * Bind an array of Server constructors to the Application's master
     * context.
     * Each server added in this way will automatically be named based on the
     * class constructor name with the "servers." prefix.
     *
     * If you wish to control the binding keys for particular server instances,
     * use the app.server function instead.
     * ```ts
     * app.servers([
     *  RestServer,
     *  GRPCServer,
     * ]);
     * // Creates a binding for "servers.RestServer" and a binding for
     * // "servers.GRPCServer";
     * ```
     *
     * @param {Constructor<Server>[]} ctors An array of Server constructors.
     * @returns {Binding[]} An array of bindings for the registered server classes
     * @memberof Application
     */
    servers(ctors) {
        return ctors.map(ctor => this.server(ctor));
    }
    /**
     * Retrieve the singleton instance for a bound constructor.
     *
     * @template T
     * @param {Constructor<T>=} ctor The constructor that was used to make the
     * binding.
     * @returns {Promise<T>}
     * @memberof Application
     */
    getServer(target) {
        return __awaiter(this, void 0, void 0, function* () {
            let key;
            // instanceof check not reliable for string.
            if (typeof target === 'string') {
                key = `${keys_1.CoreBindings.SERVERS}.${target}`;
            }
            else {
                const ctor = target;
                key = `servers.${ctor.name}`;
            }
            return (yield this.get(key));
        });
    }
    /**
     * Start the application, and all of its registered servers.
     *
     * @returns {Promise}
     * @memberof Application
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._forEachServer(s => s.start());
        });
    }
    /**
     * Stop the application instance and all of its registered servers.
     * @returns {Promise}
     * @memberof Application
     */
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._forEachServer(s => s.stop());
        });
    }
    /**
     * Helper function for iterating across all registered server components.
     * @protected
     * @template T
     * @param {(s: Server) => Promise<T>} fn The function to run against all
     * registered servers
     * @memberof Application
     */
    _forEachServer(fn) {
        return __awaiter(this, void 0, void 0, function* () {
            const bindings = this.find(`${keys_1.CoreBindings.SERVERS}.*`);
            yield Promise.all(bindings.map((binding) => __awaiter(this, void 0, void 0, function* () {
                const server = (yield this.get(binding.key));
                return yield fn(server);
            })));
        });
    }
    /**
     * Add a component to this application and register extensions such as
     * controllers, providers, and servers from the component.
     *
     * @param component The component class to add.
     *
     * ```ts
     *
     * export class ProductComponent {
     *   controllers = [ProductController];
     *   repositories = [ProductRepo, UserRepo];
     *   providers = {
     *     [AUTHENTICATION_STRATEGY]: AuthStrategy,
     *     [AUTHORIZATION_ROLE]: Role,
     *   };
     * };
     *
     * app.component(ProductComponent);
     * ```
     */
    component(component) {
        const componentKey = `components.${component.name}`;
        this.bind(componentKey).toClass(component);
        // Assuming components can be synchronously instantiated
        const instance = this.getSync(componentKey);
        component_1.mountComponent(this, instance);
    }
}
exports.Application = Application;
//# sourceMappingURL=application.js.map