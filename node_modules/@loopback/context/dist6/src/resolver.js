"use strict";
// Copyright IBM Corp. 2013,2017. All Rights Reserved.
// Node module: loopback
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
const is_promise_1 = require("./is-promise");
const inject_1 = require("./inject");
const assert = require("assert");
/**
 * Create an instance of a class which constructor has arguments
 * decorated with `@inject`.
 *
 * The function returns a class when all dependencies were
 * resolved synchronously, or a Promise otherwise.
 *
 * @param ctor The class constructor to call.
 * @param ctx The context containing values for `@inject` resolution
 * @param nonInjectedArgs Optional array of args for non-injected parameters
 */
function instantiateClass(ctor, ctx, 
    // tslint:disable-next-line:no-any
    nonInjectedArgs) {
    const argsOrPromise = resolveInjectedArguments(ctor, ctx, '');
    const propertiesOrPromise = resolveInjectedProperties(ctor, ctx);
    let inst;
    if (is_promise_1.isPromise(argsOrPromise)) {
        // Instantiate the class asynchronously
        inst = argsOrPromise.then(args => new ctor(...args));
    }
    else {
        // Instantiate the class synchronously
        inst = new ctor(...argsOrPromise);
    }
    if (is_promise_1.isPromise(propertiesOrPromise)) {
        return propertiesOrPromise.then(props => {
            if (is_promise_1.isPromise(inst)) {
                // Inject the properties asynchronously
                return inst.then(obj => Object.assign(obj, props));
            }
            else {
                // Inject the properties synchronously
                return Object.assign(inst, props);
            }
        });
    }
    else {
        if (is_promise_1.isPromise(inst)) {
            // Inject the properties asynchronously
            return inst.then(obj => Object.assign(obj, propertiesOrPromise));
        }
        else {
            // Inject the properties synchronously
            return Object.assign(inst, propertiesOrPromise);
        }
    }
}
exports.instantiateClass = instantiateClass;
/**
 * Resolve the value or promise for a given injection
 * @param ctx Context
 * @param injection Descriptor of the injection
 */
function resolve(ctx, injection) {
    if (injection.resolve) {
        // A custom resolve function is provided
        return injection.resolve(ctx, injection);
    }
    // Default to resolve the value from the context by binding key
    return ctx.getValueOrPromise(injection.bindingKey);
}
/**
 * Given a function with arguments decorated with `@inject`,
 * return the list of arguments resolved using the values
 * bound in `ctx`.

 * The function returns an argument array when all dependencies were
 * resolved synchronously, or a Promise otherwise.
 *
 * @param target The class for constructor injection or prototype for method
 * injection
 * @param ctx The context containing values for `@inject` resolution
 * @param method The method name. If set to '', the constructor will
 * be used.
 * @param nonInjectedArgs Optional array of args for non-injected parameters
 */
function resolveInjectedArguments(
    // tslint:disable-next-line:no-any
    target, ctx, method, 
    // tslint:disable-next-line:no-any
    nonInjectedArgs) {
    if (method) {
        assert(typeof target[method] === 'function', `Method ${method} not found`);
    }
    // NOTE: the array may be sparse, i.e.
    //   Object.keys(injectedArgs).length !== injectedArgs.length
    // Example value:
    //   [ , 'key1', , 'key2']
    const injectedArgs = inject_1.describeInjectedArguments(target, method);
    nonInjectedArgs = nonInjectedArgs || [];
    const argLength = method ? target[method].length : target.length;
    const args = new Array(argLength);
    let asyncResolvers = undefined;
    let nonInjectedIndex = 0;
    for (let ix = 0; ix < argLength; ix++) {
        const injection = ix < injectedArgs.length ? injectedArgs[ix] : undefined;
        if (injection == null || (!injection.bindingKey && !injection.resolve)) {
            const name = method || target.name;
            if (nonInjectedIndex < nonInjectedArgs.length) {
                // Set the argument from the non-injected list
                args[ix] = nonInjectedArgs[nonInjectedIndex++];
                continue;
            }
            else {
                throw new Error(`Cannot resolve injected arguments for function ${name}: ` +
                    `The arguments[${ix}] is not decorated for dependency injection, ` +
                    `but a value is not supplied`);
            }
        }
        const valueOrPromise = resolve(ctx, injection);
        if (is_promise_1.isPromise(valueOrPromise)) {
            if (!asyncResolvers)
                asyncResolvers = [];
            asyncResolvers.push(valueOrPromise.then((v) => (args[ix] = v)));
        }
        else {
            args[ix] = valueOrPromise;
        }
    }
    if (asyncResolvers) {
        return Promise.all(asyncResolvers).then(() => args);
    }
    else {
        return args;
    }
}
exports.resolveInjectedArguments = resolveInjectedArguments;
/**
 * Invoke an instance method with dependency injection
 * @param target Target of the method, it will be the class for a static
 * method, and instance or class prototype for a prototype method
 * @param method Name of the method
 * @param ctx Context
 * @param nonInjectedArgs Optional array of args for non-injected parameters
 */
function invokeMethod(
    // tslint:disable-next-line:no-any
    target, method, ctx, 
    // tslint:disable-next-line:no-any
    nonInjectedArgs) {
    const argsOrPromise = resolveInjectedArguments(target, ctx, method, nonInjectedArgs);
    assert(typeof target[method] === 'function', `Method ${method} not found`);
    if (is_promise_1.isPromise(argsOrPromise)) {
        // Invoke the target method asynchronously
        return argsOrPromise.then(args => target[method](...args));
    }
    else {
        // Invoke the target method synchronously
        return target[method](...argsOrPromise);
    }
}
exports.invokeMethod = invokeMethod;
function resolveInjectedProperties(fn, ctx) {
    const injectedProperties = inject_1.describeInjectedProperties(fn.prototype);
    const properties = {};
    let asyncResolvers = undefined;
    const propertyResolver = (p) => (v) => (properties[p] = v);
    for (const p in injectedProperties) {
        const injection = injectedProperties[p];
        if (!injection.bindingKey && !injection.resolve) {
            throw new Error(`Cannot resolve injected property for class ${fn.name}: ` +
                `The property ${p} was not decorated for dependency injection.`);
        }
        const valueOrPromise = resolve(ctx, injection);
        if (is_promise_1.isPromise(valueOrPromise)) {
            if (!asyncResolvers)
                asyncResolvers = [];
            asyncResolvers.push(valueOrPromise.then(propertyResolver(p)));
        }
        else {
            properties[p] = valueOrPromise;
        }
    }
    if (asyncResolvers) {
        return Promise.all(asyncResolvers).then(() => properties);
    }
    else {
        return properties;
    }
}
exports.resolveInjectedProperties = resolveInjectedProperties;
//# sourceMappingURL=resolver.js.map