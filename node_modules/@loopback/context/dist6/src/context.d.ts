import { Binding, BoundValue, ValueOrPromise } from './binding';
/**
 * Context provides an implementation of Inversion of Control (IoC) container
 */
export declare class Context {
    private _parent;
    private registry;
    /**
     * Create a new context
     * @param _parent The optional parent context
     */
    constructor(_parent?: Context | undefined);
    /**
     * Create a binding with the given key in the context. If a locked binding
     * already exists with the same key, an error will be thrown.
     *
     * @param key Binding key
     */
    bind(key: string): Binding;
    /**
     * Check if a binding exists with the given key in the local context without
     * delegating to the parent context
     * @param key Binding key
     */
    contains(key: string): boolean;
    /**
     * Check if a key is bound in the context or its ancestors
     * @param key Binding key
     */
    isBound(key: string): boolean;
    /**
     * Find bindings using the key pattern
     * @param pattern Key pattern with optional `*` wildcards
     */
    find(pattern?: string): Binding[];
    /**
     * Find bindings using the tag pattern
     * @param pattern Tag pattern with optional `*` wildcards
     */
    findByTag(pattern: string): Binding[];
    protected _mergeWithParent(childList: Binding[], parentList?: Binding[]): Binding[];
    /**
     * Get the value bound to the given key, optionally return a (deep) property
     * of the bound value.
     *
     * @example
     *
     * ```ts
     * // get the value bound to "application.instance"
     * const app = await ctx.get('application.instance');
     *
     * // get "rest" property from the value bound to "config"
     * const config = await ctx.getValueOrPromise('config#rest');
     *
     * // get "a" property of "numbers" property from the value bound to "data"
     * ctx.bind('data').to({numbers: {a: 1, b: 2}, port: 3000});
     * const a = await ctx.get('data#numbers.a');
     * ```
     *
     * @param keyWithPath The binding key, optionally suffixed with a path to the
     *   (deeply) nested property to retrieve.
     * @returns A promise of the bound value.
     */
    get(key: string): Promise<BoundValue>;
    /**
     * Get the synchronous value bound to the given key, optionally
     * return a (deep) property of the bound value.
     *
     * This method throws an error if the bound value requires async computation
     * (returns a promise). You should never rely on sync bindings in production
     * code.
     *
     * @example
     *
     * ```ts
     * // get the value bound to "application.instance"
     * const app = ctx.get('application.instance');
     *
     * // get "rest" property from the value bound to "config"
     * const config = ctx.getValueOrPromise('config#rest');
     * ```
     *
     * @param keyWithPath The binding key, optionally suffixed with a path to the
     *   (deeply) nested property to retrieve.
     * @returns A promise of the bound value.
     */
    getSync(key: string): BoundValue;
    /**
     * Look up a binding by key in the context and its ancestors. If no matching
     * binding is found, an error will be thrown.
     *
     * @param key Binding key
     */
    getBinding(key: string): Binding;
    /**
     * Get the value bound to the given key.
     *
     * This is an internal version that preserves the dual sync/async result
     * of `Binding#getValue()`. Users should use `get()` or `getSync()` instead.
     *
     * @example
     *
     * ```ts
     * // get the value bound to "application.instance"
     * ctx.getValueOrPromise('application.instance');
     *
     * // get "rest" property from the value bound to "config"
     * ctx.getValueOrPromise('config#rest');
     *
     * // get "a" property of "numbers" property from the value bound to "data"
     * ctx.bind('data').to({numbers: {a: 1, b: 2}, port: 3000});
     * ctx.getValueOrPromise('data#numbers.a');
     * ```
     *
     * @param keyWithPath The binding key, optionally suffixed with a path to the
     *   (deeply) nested property to retrieve.
     * @returns The bound value or a promise of the bound value, depending
     *   on how the binding was configured.
     * @internal
     */
    getValueOrPromise(keyWithPath: string): ValueOrPromise<BoundValue>;
    /**
     * Create a plain JSON object for the context
     */
    toJSON(): Object;
}
