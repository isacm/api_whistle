"use strict";
// Copyright IBM Corp. 2013,2017. All Rights Reserved.
// Node module: loopback
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
const reflect_1 = require("./reflect");
const PARAMETERS_KEY = 'inject:parameters';
const PROPERTIES_KEY = 'inject:properties';
/**
 * A decorator to annotate method arguments for automatic injection
 * by LoopBack IoC container.
 *
 * Usage - Typescript:
 *
 * ```ts
 * class InfoController {
 *   @inject('authentication.user') public userName: string;
 *
 *   constructor(@inject('application.name') public appName: string) {
 *   }
 *   // ...
 * }
 * ```
 *
 * Usage - JavaScript:
 *
 *  - TODO(bajtos)
 *
 * @param bindingKey What binding to use in order to resolve the value of the
 * decorated constructor parameter or property.
 * @param metadata Optional metadata to help the injection
 * @param resolve Optional function to resolve the injection
 *
 */
function inject(bindingKey, metadata, resolve) {
    return function markParameterOrPropertyAsInjected(
        // tslint:disable-next-line:no-any
        target, propertyKey, propertyDescriptorOrParameterIndex) {
        if (typeof propertyDescriptorOrParameterIndex === 'number') {
            // The decorator is applied to a method parameter
            // Please note propertyKey is `undefined` for constructor
            const injectedArgs = reflect_1.Reflector.getOwnMetadata(PARAMETERS_KEY, target, propertyKey) || [];
            injectedArgs[propertyDescriptorOrParameterIndex] = {
                bindingKey,
                metadata,
                resolve,
            };
            reflect_1.Reflector.defineMetadata(PARAMETERS_KEY, injectedArgs, target, propertyKey);
        }
        else if (propertyKey) {
            if (typeof Object.getPrototypeOf(target) === 'function') {
                const prop = target.name + '.' + propertyKey.toString();
                throw new Error('@inject is not supported for a static property: ' + prop);
            }
            // The decorator is applied to a property
            const injections = reflect_1.Reflector.getOwnMetadata(PROPERTIES_KEY, target) || {};
            injections[propertyKey] = { bindingKey, metadata, resolve };
            reflect_1.Reflector.defineMetadata(PROPERTIES_KEY, injections, target);
        }
        else {
            throw new Error('@inject can only be used on properties or method parameters.');
        }
    };
}
exports.inject = inject;
(function (inject) {
    /**
     * Inject a function for getting the actual bound value.
     *
     * This is useful when implementing Actions, where
     * the action is instantiated for Sequence constructor, but some
     * of action's dependencies become bound only after other actions
     * have been executed by the sequence.
     *
     * See also `Getter<T>`.
     *
     * @param bindingKey The key of the value we want to eventually get.
     * @param metadata Optional metadata to help the injection
     */
    inject.getter = function injectGetter(bindingKey, metadata) {
        return inject(bindingKey, metadata, resolveAsGetter);
    };
    /**
     * Inject a function for setting (binding) the given key to a given
     * value. (Only static/constant values are supported, it's not possible
     * to bind a key to a class or a provider.)
     *
     * This is useful e.g. when implementing Actions that are contributing
     * new Elements.
     *
     * See also `Setter<T>`.
     *
     * @param bindingKey The key of the value we want to set.
     * @param metadata Optional metadata to help the injection
     */
    inject.setter = function injectSetter(bindingKey, metadata) {
        return inject(bindingKey, metadata, resolveAsSetter);
    };
})(inject = exports.inject || (exports.inject = {}));
function resolveAsGetter(ctx, injection) {
    return function getter() {
        return ctx.get(injection.bindingKey);
    };
}
function resolveAsSetter(ctx, injection) {
    return function setter(value) {
        ctx.bind(injection.bindingKey).to(value);
    };
}
/**
 * Return an array of injection objects for parameters
 * @param target The target class for constructor or static methods,
 * or the prototype for instance methods
 * @param method Method name, undefined for constructor
 */
function describeInjectedArguments(
    // tslint:disable-next-line:no-any
    target, method) {
    if (method) {
        return reflect_1.Reflector.getMetadata(PARAMETERS_KEY, target, method) || [];
    }
    else {
        return reflect_1.Reflector.getMetadata(PARAMETERS_KEY, target) || [];
    }
}
exports.describeInjectedArguments = describeInjectedArguments;
/**
 * Return a map of injection objects for properties
 * @param target The target class for static properties or
 * prototype for instance properties.
 */
function describeInjectedProperties(
    // tslint:disable-next-line:no-any
    target) {
    const metadata = {};
    let obj = target;
    while (true) {
        const m = reflect_1.Reflector.getOwnMetadata(PROPERTIES_KEY, obj);
        if (m) {
            // Adding non-existent properties
            for (const p in m) {
                if (!(p in metadata)) {
                    metadata[p] = m[p];
                }
            }
        }
        // Recurse into the prototype chain
        obj = Object.getPrototypeOf(obj);
        if (!obj)
            break;
    }
    return metadata;
}
exports.describeInjectedProperties = describeInjectedProperties;
//# sourceMappingURL=inject.js.map