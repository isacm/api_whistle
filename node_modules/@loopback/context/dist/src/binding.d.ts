import { Context } from './context';
import { Constructor } from './resolver';
import { Provider } from './provider';
export declare type BoundValue = any;
export declare type ValueOrPromise<T> = T | Promise<T>;
/**
 * Scope for binding values
 */
export declare enum BindingScope {
    /**
     * The binding provides a value that is calculated each time. This will be
     * the default scope if not set.
     *
     * For example, with the following context hierarchy:
     *
     * - app (with a binding 'b1' that produces sequential values 0, 1, ...)
     *   - req1
     *   - req2
     *
     * // get('b1') produces a new value each time for app and its descendants
     * app.get('b1') ==> 0
     * req1.get('b1') ==> 1
     * req2.get('b1') ==> 2
     * req2.get('b1') ==> 3
     * app.get('b1') ==> 4
     */
    TRANSIENT = "Transient",
    /**
     * The binding provides a value as a singleton within each local context. The
     * value is calculated only once per context and cached for subsequenicial
     * uses. Child contexts have their own value and do not share with their
     * ancestors.
     *
     * For example, with the following context hierarchy:
     *
     * - app (with a binding 'b1' that produces sequential values 0, 1, ...)
     *   - req1
     *   - req2
     *
     * // 0 is the singleton for app afterward
     * app.get('b1') ==> 0
     *
     * // 'b1' is found in app but not in req1, a new value 1 is calculated.
     * // 1 is the singleton for req1 afterward
     * req1.get('b1') ==> 1
     *
     * // 'b1' is found in app but not in req2, a new value 2 is calculated.
     * // 2 is the singleton for req2 afterward
     * req2.get('b1') ==> 2
     */
    CONTEXT = "Context",
    /**
     * The binding provides a value as a singleton within the context hierarchy
     * (the owning context and its descendants). The value is calculated only
     * once for the owning context and cached for subsequenicial uses. Child
     * contexts share the same value as their ancestors.
     *
     * For example, with the following context hierarchy:
     *
     * - app (with a binding 'b1' that produces sequential values 0, 1, ...)
     *   - req1
     *   - req2
     *
     * // 0 is the singleton for app afterward
     * app.get('b1') ==> 0
     *
     * // 'b1' is found in app, reuse it
     * req1.get('b1') ==> 0
     *
     * // 'b1' is found in app, reuse it
     * req2.get('b1') ==> 0
     */
    SINGLETON = "Singleton",
}
export declare enum BindingType {
    CONSTANT = "Constant",
    DYNAMIC_VALUE = "DynamicValue",
    CLASS = "Class",
    PROVIDER = "Provider",
}
export declare class Binding {
    isLocked: boolean;
    static PROPERTY_SEPARATOR: string;
    /**
     * Validate the binding key format. Please note that `#` is reserved.
     * @param key Binding key, such as `a, a.b, a:b, a/b
     */
    static validateKey(key: string): string;
    /**
     * Parse a string containing both the binding key and the path to the deeply
     * nested property to retrieve.
     *
     * @param keyWithPath The key with an optional path,
     *  e.g. "application.instance" or "config#rest.port".
     */
    static parseKeyWithPath(keyWithPath: string): {
        key: string;
        path: undefined;
    } | {
        key: string;
        path: string;
    };
    readonly key: string;
    readonly tags: Set<string>;
    scope: BindingScope;
    type: BindingType;
    private _cache;
    private _getValue;
    valueConstructor: Constructor<BoundValue>;
    constructor(key: string, isLocked?: boolean);
    /**
     * Cache the resolved value by the binding scope
     * @param ctx The current context
     * @param result The calculated value for the binding
     */
    private _cacheValue(ctx, result);
    /**
     * This is an internal function optimized for performance.
     * Users should use `@inject(key)` or `ctx.get(key)` instead.
     *
     * Get the value bound to this key. Depending on `isSync`, this
     * function returns either:
     *  - the bound value
     *  - a promise of the bound value
     *
     * Consumers wishing to consume sync values directly should use `isPromise`
     * to check the type of the returned value to decide how to handle it.
     *
     * ```
     * const result = binding.getValue(ctx);
     * if (isPromise(result)) {
     *   result.then(doSomething)
     * } else {
     *   doSomething(result);
     * }
     * ```
     */
    getValue(ctx: Context): BoundValue | Promise<BoundValue>;
    lock(): this;
    tag(tagName: string | string[]): this;
    inScope(scope: BindingScope): this;
    /**
     * Bind the key to a constant value.
     *
     * @param value The bound value.
     *
     * @example
     *
     * ```ts
     * ctx.bind('appName').to('CodeHub');
     * ```
     */
    to(value: BoundValue): this;
    /**
     * Bind the key to a computed (dynamic) value.
     *
     * @param factoryFn The factory function creating the value.
     *   Both sync and async functions are supported.
     *
     * @example
     *
     * ```ts
     * // synchronous
     * ctx.bind('now').toDynamicValue(() => Date.now());
     *
     * // asynchronous
     * ctx.bind('something').toDynamicValue(
     *  async () => Promise.delay(10).then(doSomething)
     * );
     * ```
     */
    toDynamicValue(factoryFn: () => BoundValue | Promise<BoundValue>): this;
    /**
     * Bind the key to a value computed by a Provider.
     *
     * * @example
     *
     * ```ts
     * export class DateProvider implements Provider<Date> {
     *   constructor(@inject('stringDate') private param: String){}
     *   value(): Date {
     *     return new Date(param);
     *   }
     * }
     * ```
     *
     * @param provider The value provider to use.
     */
    toProvider<T>(providerClass: Constructor<Provider<T>>): this;
    /**
     * Bind the key to an instance of the given class.
     *
     * @param ctor The class constructor to call. Any constructor
     *   arguments must be annotated with `@inject` so that
     *   we can resolve them from the context.
     */
    toClass<T>(ctor: Constructor<T>): this;
    unlock(): this;
    toJSON(): Object;
}
