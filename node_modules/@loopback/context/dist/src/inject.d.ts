import { BoundValue, ValueOrPromise } from './binding';
import { Context } from './context';
/**
 * A function to provide resolution of injected values
 */
export interface ResolverFunction {
    (ctx: Context, injection: Injection): ValueOrPromise<BoundValue>;
}
/**
 * Descriptor for an injection point
 */
export interface Injection {
    bindingKey: string;
    metadata?: {
        [attribute: string]: BoundValue;
    };
    resolve?: ResolverFunction;
}
/**
 * A decorator to annotate method arguments for automatic injection
 * by LoopBack IoC container.
 *
 * Usage - Typescript:
 *
 * ```ts
 * class InfoController {
 *   @inject('authentication.user') public userName: string;
 *
 *   constructor(@inject('application.name') public appName: string) {
 *   }
 *   // ...
 * }
 * ```
 *
 * Usage - JavaScript:
 *
 *  - TODO(bajtos)
 *
 * @param bindingKey What binding to use in order to resolve the value of the
 * decorated constructor parameter or property.
 * @param metadata Optional metadata to help the injection
 * @param resolve Optional function to resolve the injection
 *
 */
export declare function inject(bindingKey: string, metadata?: Object, resolve?: ResolverFunction): (target: any, propertyKey?: string | symbol | undefined, propertyDescriptorOrParameterIndex?: number | TypedPropertyDescriptor<any> | undefined) => void;
/**
 * The function injected by `@inject.getter(key)`.
 */
export declare type Getter<T> = () => Promise<T>;
/**
 * The function injected by `@inject.setter(key)`.
 */
export declare type Setter<T> = (value: T) => void;
export declare namespace inject {
    /**
     * Inject a function for getting the actual bound value.
     *
     * This is useful when implementing Actions, where
     * the action is instantiated for Sequence constructor, but some
     * of action's dependencies become bound only after other actions
     * have been executed by the sequence.
     *
     * See also `Getter<T>`.
     *
     * @param bindingKey The key of the value we want to eventually get.
     * @param metadata Optional metadata to help the injection
     */
    const getter: (bindingKey: string, metadata?: Object | undefined) => (target: any, propertyKey?: string | symbol | undefined, propertyDescriptorOrParameterIndex?: number | TypedPropertyDescriptor<any> | undefined) => void;
    /**
     * Inject a function for setting (binding) the given key to a given
     * value. (Only static/constant values are supported, it's not possible
     * to bind a key to a class or a provider.)
     *
     * This is useful e.g. when implementing Actions that are contributing
     * new Elements.
     *
     * See also `Setter<T>`.
     *
     * @param bindingKey The key of the value we want to set.
     * @param metadata Optional metadata to help the injection
     */
    const setter: (bindingKey: string, metadata?: Object | undefined) => (target: any, propertyKey?: string | symbol | undefined, propertyDescriptorOrParameterIndex?: number | TypedPropertyDescriptor<any> | undefined) => void;
}
/**
 * Return an array of injection objects for parameters
 * @param target The target class for constructor or static methods,
 * or the prototype for instance methods
 * @param method Method name, undefined for constructor
 */
export declare function describeInjectedArguments(target: any, method?: string | symbol): Injection[];
/**
 * Return a map of injection objects for properties
 * @param target The target class for static properties or
 * prototype for instance properties.
 */
export declare function describeInjectedProperties(target: any): {
    [p: string]: Injection;
};
