"use strict";
// Copyright IBM Corp. 2017. All Rights Reserved.
// Node module: @loopback/rest
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = require("./");
const core_1 = require("@loopback/core");
const jsonBody = require('body/json');
// tslint:enable:no-any
const parseJsonBody = core_1.promisify(jsonBody);
/**
 * Get the content-type header value from the request
 * @param req Http request
 */
function getContentType(req) {
    const val = req.headers['content-type'];
    if (typeof val === 'string') {
        return val;
    }
    else if (Array.isArray(val)) {
        // Assume only one value is present
        return val[0];
    }
    return undefined;
}
/**
 * Parses the request to derive arguments to be passed in for the Application
 * controller method
 *
 * @param request Incoming HTTP request
 * @param operationSpec Swagger spec defined in the controller
 * @param pathParams Path parameters in incoming HTTP request
 */
async function parseOperationArgs(request, route) {
    const operationSpec = route.spec;
    const pathParams = route.pathParams;
    const body = await loadRequestBodyIfNeeded(operationSpec, request);
    return buildOperationArguments(operationSpec, request, pathParams, body);
}
exports.parseOperationArgs = parseOperationArgs;
function loadRequestBodyIfNeeded(operationSpec, request) {
    if (!hasArgumentsFromBody(operationSpec))
        return Promise.resolve();
    const contentType = getContentType(request);
    if (contentType && !/json/.test(contentType)) {
        const err = new _1.HttpErrors.UnsupportedMediaType(`Content-type ${contentType} is not supported.`);
        return Promise.reject(err);
    }
    return parseJsonBody(request).catch((err) => {
        err.statusCode = 400;
        return Promise.reject(err);
    });
}
function hasArgumentsFromBody(operationSpec) {
    if (!operationSpec.parameters || !operationSpec.parameters.length)
        return false;
    for (const paramSpec of operationSpec.parameters) {
        if ('$ref' in paramSpec)
            continue;
        const source = paramSpec.in;
        if (source === 'formData' || source === 'body')
            return true;
    }
    return false;
}
function buildOperationArguments(operationSpec, request, pathParams, body) {
    const args = [];
    for (const paramSpec of operationSpec.parameters || []) {
        if ('$ref' in paramSpec) {
            // TODO(bajtos) implement $ref parameters
            // See https://github.com/strongloop/loopback-next/issues/435
            throw new Error('$ref parameters are not supported yet.');
        }
        const spec = paramSpec;
        switch (spec.in) {
            case 'query':
                args.push(request.query[spec.name]);
                break;
            case 'path':
                args.push(pathParams[spec.name]);
                break;
            case 'header':
                args.push(request.headers[spec.name.toLowerCase()]);
                break;
            case 'formData':
                args.push(body ? body[spec.name] : undefined);
                break;
            case 'body':
                args.push(body);
                break;
            default:
                throw new _1.HttpErrors.NotImplemented('Parameters with "in: ' + spec.in + '" are not supported yet.');
        }
    }
    return args;
}
//# sourceMappingURL=parser.js.map