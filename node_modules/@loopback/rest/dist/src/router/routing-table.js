"use strict";
// Copyright IBM Corp. 2017. All Rights Reserved.
// Node module: @loopback/rest
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
const context_1 = require("@loopback/context");
const HttpErrors = require("http-errors");
const assert = require("assert");
const url = require("url");
const debug = require('debug')('loopback:core:routing-table');
// TODO(bajtos) Refactor this code to use Trie-based lookup,
// e.g. via wayfarer/trie or find-my-way
// See https://github.com/strongloop/loopback-next/issues/98
const pathToRegexp = require("path-to-regexp");
/**
 * Parse the URL of the incoming request and set additional properties
 * on this request object:
 *  - `path`
 *  - `query`
 *
 * @private
 * @param request
 */
function parseRequestUrl(request) {
    // TODO(bajtos) The following parsing can be skipped when the router
    // is mounted on an express app
    const parsedRequest = request;
    const parsedUrl = url.parse(parsedRequest.url, true);
    parsedRequest.path = parsedUrl.pathname || '/';
    parsedRequest.query = parsedUrl.query;
    return parsedRequest;
}
exports.parseRequestUrl = parseRequestUrl;
class RoutingTable {
    constructor() {
        this._routes = [];
    }
    registerController(controller, spec) {
        assert(typeof spec === 'object' && !!spec, 'API specification must be a non-null object');
        if (!spec.paths || !Object.keys(spec.paths).length) {
            return;
        }
        debug('Registering Controller with API', spec);
        const basePath = spec.basePath || '/';
        for (const p in spec.paths) {
            for (const verb in spec.paths[p]) {
                const opSpec = spec.paths[p][verb];
                const fullPath = RoutingTable.joinPath(basePath, p);
                const route = new ControllerRoute(verb, fullPath, opSpec, controller);
                this.registerRoute(route);
            }
        }
    }
    static joinPath(basePath, path) {
        const fullPath = [basePath, path]
            .join('/') // Join by /
            .replace(/(\/){2,}/g, '/') // Remove extra /
            .replace(/\/$/, '') // Remove trailing /
            .replace(/^(\/)?/, '/'); // Add leading /
        return fullPath;
    }
    registerRoute(route) {
        // TODO(bajtos) handle the case where opSpec.parameters contains $ref
        // See https://github.com/strongloop/loopback-next/issues/435
        debug('Registering route %s %s -> %s(%s)', route.verb, route.path, route.describe(), describeOperationParameters(route.spec));
        this._routes.push(route);
    }
    describeApiPaths() {
        const paths = {};
        for (const route of this._routes) {
            if (!paths[route.path]) {
                paths[route.path] = {};
            }
            paths[route.path][route.verb] = route.spec;
        }
        return paths;
    }
    find(request) {
        for (const entry of this._routes) {
            const match = entry.match(request);
            if (match)
                return match;
        }
        throw new HttpErrors.NotFound(`Endpoint "${request.method} ${request.path}" not found.`);
    }
}
exports.RoutingTable = RoutingTable;
class BaseRoute {
    constructor(verb, path, spec) {
        this.path = path;
        this.spec = spec;
        this._keys = [];
        this.verb = verb.toLowerCase();
        // In Swagger, path parameters are wrapped in `{}`.
        // In Express.js, path parameters are prefixed with `:`
        path = path.replace(/{([^}]*)}(\/|$)/g, ':$1$2');
        this._pathRegexp = pathToRegexp(path, this._keys, {
            strict: false,
            end: true,
        });
    }
    match(request) {
        debug('trying endpoint', this);
        if (this.verb !== request.method.toLowerCase()) {
            debug(' -> verb mismatch');
            return undefined;
        }
        const match = this._pathRegexp.exec(request.path);
        if (!match) {
            debug(' -> path mismatch');
            return undefined;
        }
        const pathParams = this._buildPathParams(match);
        debug(' -> found with params: %j', pathParams);
        return createResolvedRoute(this, pathParams);
    }
    describe() {
        return `"${this.verb} ${this.path}"`;
    }
    _buildPathParams(pathMatch) {
        const pathParams = Object.create(null);
        for (const ix in this._keys) {
            const key = this._keys[ix];
            const matchIndex = +ix + 1;
            pathParams[key.name] = pathMatch[matchIndex];
        }
        return pathParams;
    }
}
exports.BaseRoute = BaseRoute;
function createResolvedRoute(route, pathParams) {
    return Object.create(route, {
        pathParams: {
            writable: false,
            value: pathParams,
        },
    });
}
exports.createResolvedRoute = createResolvedRoute;
class Route extends BaseRoute {
    constructor(verb, path, spec, _handler) {
        super(verb, path, spec);
        this.spec = spec;
        this._handler = _handler;
    }
    describe() {
        return this._handler.name || super.describe();
    }
    updateBindings(requestContext) {
        // no-op
    }
    async invokeHandler(requestContext, args) {
        return await this._handler(...args);
    }
}
exports.Route = Route;
class ControllerRoute extends BaseRoute {
    constructor(verb, path, spec, _controllerCtor, methodName) {
        super(verb, path, 
        // Add x-controller-name and x-operation-name if not present
        Object.assign({
            'x-controller-name': _controllerCtor.name,
            'x-operation-name': methodName,
        }, spec));
        this._controllerCtor = _controllerCtor;
        if (!methodName) {
            methodName = this.spec['x-operation-name'];
        }
        if (!methodName) {
            throw new Error('methodName must be provided either via the ControllerRoute argument ' +
                'or via "x-operation-name" extension field in OpenAPI spec. ' +
                `Operation: "${verb} ${path}" ` +
                `Controller: ${this._controllerCtor.name}.`);
        }
        this._methodName = methodName;
    }
    describe() {
        return `${this._controllerCtor.name}.${this._methodName}`;
    }
    updateBindings(requestContext) {
        const ctor = this._controllerCtor;
        requestContext.bind('controller.current.ctor').to(ctor);
        requestContext.bind('controller.current.operation').to(this._methodName);
    }
    async invokeHandler(requestContext, args) {
        const controller = await this._createControllerInstance(requestContext);
        if (typeof controller[this._methodName] !== 'function') {
            throw new HttpErrors.NotFound(`Controller method not found: ${this.describe()}`);
        }
        return await controller[this._methodName](...args);
    }
    async _createControllerInstance(requestContext) {
        const valueOrPromise = context_1.instantiateClass(this._controllerCtor, requestContext);
        return (await Promise.resolve(valueOrPromise));
    }
}
exports.ControllerRoute = ControllerRoute;
function describeOperationParameters(opSpec) {
    return (opSpec.parameters || [])
        .map(p => p.name)
        .join(', ');
}
//# sourceMappingURL=routing-table.js.map