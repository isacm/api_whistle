"use strict";
// Copyright IBM Corp. 2017. All Rights Reserved.
// Node module: @loopback/rest
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = require("assert");
const swagger2openapi = require('swagger2openapi');
const js_yaml_1 = require("js-yaml");
const context_1 = require("@loopback/context");
const _1 = require(".");
const openapi_spec_1 = require("@loopback/openapi-spec");
const http_1 = require("http");
const core_1 = require("@loopback/core");
const metadata_1 = require("./router/metadata");
const http_handler_1 = require("./http-handler");
const sequence_1 = require("./sequence");
const keys_1 = require("./keys");
const SequenceActions = keys_1.RestBindings.SequenceActions;
// NOTE(bajtos) we cannot use `import * as cloneDeep from 'lodash/cloneDeep'
// because it produces the following TypeScript error:
//  Module '"(...)/node_modules/@types/lodash/cloneDeep/index"' resolves to
//  a non-module entity and cannot be imported using this construct.
const cloneDeep = require('lodash/cloneDeep');
const OPENAPI_SPEC_MAPPING = {
    '/openapi.json': { version: '3.0.0', format: 'json' },
    '/openapi.yaml': { version: '3.0.0', format: 'yaml' },
    '/swagger.json': { version: '2.0', format: 'json' },
    '/swagger.yaml': { version: '2.0', format: 'yaml' },
};
/**
 * A REST API server for use with Loopback.
 * Add this server to your application by importing the RestComponent.
 * ```ts
 * const app = new MyApplication({
 *   components: [RestComponent]
 * });
 * // OR
 * app.component(RestComponent);
 * ```
 *
 * To add additional instances of RestServer to your application, use the
 * `.server` function:
 * ```ts
 * app.server(RestServer, 'nameOfYourServer');
 * ```
 *
 * By default, one instance of RestServer will be created when the RestComponent
 * is bootstrapped. This instance can be retrieved with
 * `app.getServer(RestServer)`, or by calling `app.get('servers.RestServer')`
 * Note that retrieving other instances of RestServer must be done using the
 * server's name:
 * ```ts
 * const server = await app.getServer('foo')
 * // OR
 * const server = await app.get('servers.foo');
 * ```
 *
 * @export
 * @class RestServer
 * @extends {Context}
 * @implements {Server}
 */
let RestServer = class RestServer extends context_1.Context {
    /**
     * @memberof RestServer
     * Creates an instance of RestServer.
     *
     * @param {Application} app The application instance (injected via
     * CoreBindings.APPLICATION_INSTANCE).
     * @param {RestServerConfig=} options The configuration options (injected via
     * RestBindings.CONFIG).
     *
     */
    constructor(app, options) {
        super(app);
        options = options || {};
        // Can't check falsiness, 0 is a valid port.
        if (options.port == null) {
            options.port = 3000;
        }
        if (options.host == null) {
            options.host = 'localhost';
        }
        this.bind(keys_1.RestBindings.PORT).to(options.port);
        this.bind(keys_1.RestBindings.HOST).to(options.host);
        this.api(openapi_spec_1.createEmptyApiSpec());
        this.sequence(options.sequence ? options.sequence : sequence_1.DefaultSequence);
        this.handleHttp = (req, res) => {
            try {
                this._handleHttpRequest(req, res, options).catch(err => this._onUnhandledError(req, res, err));
            }
            catch (err) {
                this._onUnhandledError(req, res, err);
            }
        };
        this.bind(keys_1.RestBindings.HANDLER).toDynamicValue(() => this.httpHandler);
    }
    get httpHandler() {
        this._setupHandlerIfNeeded();
        return this._httpHandler;
    }
    _handleHttpRequest(request, response, options) {
        // allow CORS support for all endpoints so that users
        // can test with online SwaggerUI instance
        response.setHeader('Access-Control-Allow-Origin', '*');
        response.setHeader('Access-Control-Allow-Credentials', 'true');
        response.setHeader('Access-Control-Allow-Max-Age', '86400');
        if (request.method === 'GET' &&
            request.url &&
            request.url in OPENAPI_SPEC_MAPPING) {
            // NOTE(bajtos) Regular routes are handled through Sequence.
            // IMO, this built-in endpoint should not run through a Sequence,
            // because it's not part of the application API itself.
            // E.g. if the app implements access/audit logs, I don't want
            // this endpoint to trigger a log entry. If the server implements
            // content-negotiation to support XML clients, I don't want the OpenAPI
            // spec to be converted into an XML response.
            const settings = OPENAPI_SPEC_MAPPING[request.url];
            return this._serveOpenApiSpec(request, response, settings);
        }
        if (request.method === 'GET' &&
            request.url &&
            request.url === '/swagger-ui') {
            return this._redirectToSwaggerUI(request, response, options);
        }
        return this.httpHandler.handleRequest(request, response);
    }
    _setupHandlerIfNeeded() {
        // TODO(bajtos) support hot-reloading of controllers
        // after the app started. The idea is to rebuild the HttpHandler
        // instance whenever a controller was added/deleted.
        // See https://github.com/strongloop/loopback-next/issues/433
        if (this._httpHandler)
            return;
        this._httpHandler = new http_handler_1.HttpHandler(this);
        for (const b of this.find('controllers.*')) {
            const controllerName = b.key.replace(/^controllers\./, '');
            const ctor = b.valueConstructor;
            if (!ctor) {
                throw new Error(`The controller ${controllerName} was not bound via .toClass()`);
            }
            const apiSpec = metadata_1.getControllerSpec(ctor);
            if (!apiSpec) {
                // controller methods are specified through app.api() spec
                continue;
            }
            this._httpHandler.registerController(ctor, apiSpec);
        }
        for (const b of this.find('routes.*')) {
            // TODO(bajtos) should we support routes defined asynchronously?
            const route = this.getSync(b.key);
            this._httpHandler.registerRoute(route);
        }
        // TODO(bajtos) should we support API spec defined asynchronously?
        const spec = this.getSync(keys_1.RestBindings.API_SPEC);
        for (const path in spec.paths) {
            for (const verb in spec.paths[path]) {
                const routeSpec = spec.paths[path][verb];
                this._setupOperation(verb, path, routeSpec);
            }
        }
    }
    _setupOperation(verb, path, spec) {
        const handler = spec['x-operation'];
        if (typeof handler === 'function') {
            // Remove a field value that cannot be represented in JSON.
            // Start by creating a shallow-copy of the spec, so that we don't
            // modify the original spec object provided by user.
            spec = Object.assign({}, spec);
            delete spec['x-operation'];
            const route = new _1.Route(verb, path, spec, handler);
            this._httpHandler.registerRoute(route);
            return;
        }
        const controllerName = spec['x-controller-name'];
        if (typeof controllerName === 'string') {
            const b = this.find(`controllers.${controllerName}`)[0];
            if (!b) {
                throw new Error(`Unknown controller ${controllerName} used by "${verb} ${path}"`);
            }
            const ctor = b.valueConstructor;
            if (!ctor) {
                throw new Error(`The controller ${controllerName} was not bound via .toClass()`);
            }
            const route = new _1.ControllerRoute(verb, path, spec, ctor);
            this._httpHandler.registerRoute(route);
            return;
        }
        throw new Error(`There is no handler configured for operation "${verb} ${path}`);
    }
    async _serveOpenApiSpec(request, response, options) {
        options = options || { version: '2.0', format: 'json' };
        let specObj = this.getApiSpec();
        if (options.version === '3.0.0') {
            specObj = await swagger2openapi.convertObj(specObj, { direct: true });
        }
        if (options.format === 'json') {
            const spec = JSON.stringify(specObj, null, 2);
            response.setHeader('content-type', 'application/json; charset=utf-8');
            response.end(spec, 'utf-8');
        }
        else {
            const yaml = js_yaml_1.safeDump(specObj, {});
            response.setHeader('content-type', 'text/yaml; charset=utf-8');
            response.end(yaml, 'utf-8');
        }
    }
    async _redirectToSwaggerUI(request, response, options) {
        response.statusCode = 308;
        const baseUrl = options.apiExplorerUrl || 'https://loopback.io/api-explorer';
        response.setHeader('Location', `${baseUrl}?url=http://${request.headers.host}/swagger.json`);
        response.end();
    }
    /**
     * Register a controller class with this server.
     *
     * @param {Constructor} controllerCtor The controller class
     * (constructor function).
     * @returns {Binding} The newly created binding, you can use the reference to
     * further modify the binding, e.g. lock the value to prevent further
     * modifications.
     *
     * ```ts
     * class MyController {
     * }
     * app.controller(MyController).lock();
     * ```
     *
     */
    controller(controllerCtor) {
        return this.bind('controllers.' + controllerCtor.name).toClass(controllerCtor);
    }
    route(routeOrVerb, path, spec, controller, methodName) {
        if (typeof routeOrVerb === 'object') {
            const r = routeOrVerb;
            return this.bind(`routes.${r.verb} ${r.path}`).to(r);
        }
        if (!path) {
            throw new assert_1.AssertionError({
                message: 'path is required for a controller-based route',
            });
        }
        if (!spec) {
            throw new assert_1.AssertionError({
                message: 'spec is required for a controller-based route',
            });
        }
        if (!controller) {
            throw new assert_1.AssertionError({
                message: 'controller is required for a controller-based route',
            });
        }
        if (!methodName) {
            throw new assert_1.AssertionError({
                message: 'methodName is required for a controller-based route',
            });
        }
        return this.route(new _1.ControllerRoute(routeOrVerb, path, spec, controller, methodName));
    }
    /**
     * Set the OpenAPI specification that defines the REST API schema for this
     * server. All routes, parameter definitions and return types will be defined
     * in this way.
     *
     * Note that this will override any routes defined via decorators at the
     * controller level (this function takes precedent).
     *
     * @param {OpenApiSpec} spec The OpenAPI specification, as an object.
     * @returns {Binding}
     * @memberof RestServer
     */
    api(spec) {
        return this.bind(keys_1.RestBindings.API_SPEC).to(spec);
    }
    /**
     * Get the OpenAPI specification describing the REST API provided by
     * this application.
     *
     * This method merges operations (HTTP endpoints) from the following sources:
     *  - `app.api(spec)`
     *  - `app.controller(MyController)`
     *  - `app.route(route)`
     *  - `app.route('get', '/greet', operationSpec, MyController, 'greet')`
     */
    getApiSpec() {
        const spec = this.getSync(keys_1.RestBindings.API_SPEC);
        // Apply deep clone to prevent getApiSpec() callers from
        // accidentally modifying our internal routing data
        spec.paths = cloneDeep(this.httpHandler.describeApiPaths());
        return spec;
    }
    /**
     * Configure a custom sequence class for handling incoming requests.
     *
     * ```ts
     * class MySequence implements SequenceHandler {
     *   constructor(
     *     @inject('send) public send: Send)) {
     *   }
     *
     *   public async handle(request: ParsedRequest, response: ServerResponse) {
     *     send(response, 'hello world');
     *   }
     * }
     * ```
     *
     * @param value The sequence to invoke for each incoming request.
     */
    sequence(value) {
        this.bind(keys_1.RestBindings.SEQUENCE).toClass(value);
    }
    /**
     * Configure a custom sequence function for handling incoming requests.
     *
     * ```ts
     * app.handler((sequence, request, response) => {
     *   sequence.send(response, 'hello world');
     * });
     * ```
     *
     * @param handlerFn The handler to invoke for each incoming request.
     */
    handler(handlerFn) {
        let SequenceFromFunction = class SequenceFromFunction extends sequence_1.DefaultSequence {
            // NOTE(bajtos) Unfortunately, we have to duplicate the constructor
            // in order for our DI/IoC framework to inject constructor arguments
            constructor(ctx, findRoute, parseParams, invoke, send, reject) {
                super(ctx, findRoute, parseParams, invoke, send, reject);
                this.ctx = ctx;
                this.findRoute = findRoute;
                this.parseParams = parseParams;
                this.invoke = invoke;
                this.send = send;
                this.reject = reject;
            }
            async handle(request, response) {
                await Promise.resolve(handlerFn(this, request, response));
            }
        };
        SequenceFromFunction = __decorate([
            __param(0, context_1.inject(keys_1.RestBindings.Http.CONTEXT)),
            __param(1, context_1.inject(SequenceActions.FIND_ROUTE)),
            __param(2, context_1.inject(SequenceActions.PARSE_PARAMS)),
            __param(3, context_1.inject(SequenceActions.INVOKE_METHOD)),
            __param(4, context_1.inject(SequenceActions.SEND)),
            __param(5, context_1.inject(SequenceActions.REJECT)),
            __metadata("design:paramtypes", [context_1.Context, Function, Function, Function, Function, Function])
        ], SequenceFromFunction);
        this.sequence(SequenceFromFunction);
    }
    /**
     * Start this REST API's HTTP/HTTPS server.
     *
     * @returns {Promise<void>}
     * @memberof RestServer
     */
    async start() {
        // Setup the HTTP handler so that we can verify the configuration
        // of API spec, controllers and routes at startup time.
        this._setupHandlerIfNeeded();
        const httpPort = await this.get(keys_1.RestBindings.PORT);
        const httpHost = await this.get(keys_1.RestBindings.HOST);
        this._httpServer = http_1.createServer(this.handleHttp);
        const httpServer = this._httpServer;
        // TODO(bajtos) support httpHostname too
        // See https://github.com/strongloop/loopback-next/issues/434
        httpServer.listen(httpPort, httpHost);
        return new Promise((resolve, reject) => {
            httpServer.once('listening', () => {
                this.bind(keys_1.RestBindings.PORT).to(httpServer.address().port);
                resolve();
            });
            httpServer.once('error', reject);
        });
    }
    /**
     * Stop this REST API's HTTP/HTTPS server.
     *
     * @returns {Promise<void>}
     * @memberof RestServer
     */
    async stop() {
        // Kill the server instance.
        const server = this._httpServer;
        return new Promise((resolve, reject) => {
            server.close((err) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
    }
    _onUnhandledError(req, res, err) {
        if (!res.headersSent) {
            res.statusCode = 500;
            res.end();
        }
        // It's the responsibility of the Sequence to handle any errors.
        // If an unhandled error escaped, then something very wrong happened
        // and it's best to crash the process immediately.
        process.nextTick(() => {
            throw err;
        });
    }
};
RestServer = __decorate([
    __param(0, context_1.inject(core_1.CoreBindings.APPLICATION_INSTANCE)),
    __param(1, context_1.inject(keys_1.RestBindings.CONFIG)),
    __metadata("design:paramtypes", [core_1.Application, Object])
], RestServer);
exports.RestServer = RestServer;
//# sourceMappingURL=rest-server.js.map