"use strict";
// Copyright IBM Corp. 2017. All Rights Reserved.
// Node module: @loopback/rest
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const context_1 = require("@loopback/context");
const routing_table_1 = require("./router/routing-table");
const keys_1 = require("./keys");
class HttpHandler {
    constructor(_rootContext) {
        this._rootContext = _rootContext;
        this._routes = new routing_table_1.RoutingTable();
        this.handleRequest = (req, res) => this._handleRequest(req, res);
    }
    registerController(name, spec) {
        this._routes.registerController(name, spec);
    }
    registerRoute(route) {
        this._routes.registerRoute(route);
    }
    describeApiPaths() {
        return this._routes.describeApiPaths();
    }
    findRoute(request) {
        return this._routes.find(request);
    }
    _handleRequest(request, response) {
        return __awaiter(this, void 0, void 0, function* () {
            const parsedRequest = routing_table_1.parseRequestUrl(request);
            const requestContext = this._createRequestContext(request, response);
            const sequence = yield requestContext.get(keys_1.RestBindings.SEQUENCE);
            yield sequence.handle(parsedRequest, response);
        });
    }
    _createRequestContext(req, res) {
        const requestContext = new context_1.Context(this._rootContext);
        requestContext.bind(keys_1.RestBindings.Http.REQUEST).to(req);
        requestContext.bind(keys_1.RestBindings.Http.RESPONSE).to(res);
        requestContext.bind(keys_1.RestBindings.Http.CONTEXT).to(requestContext);
        return requestContext;
    }
}
exports.HttpHandler = HttpHandler;
//# sourceMappingURL=http-handler.js.map